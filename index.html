<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Silent Defense - Reworked Layout and UI</title>
    <style>
        :root {
            --grid-cols: 15; /* New Width */
            --grid-rows: 4;  /* New Height */
            --cell-size: 60px; /* Reduced cell size for fitting more tiles */
            --grid-width: calc(var(--grid-cols) * var(--cell-size));
            --grid-height: calc(var(--grid-rows) * var(--cell-size));

            --dark-color: #1a1a2e;
            --accent-color: #e94560;
            --gold-color: gold;
            --power-color: #00ffff;
            --door-color: #a0522d;
            --door-knob-color: #ffd700;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end; 
            min-height: 100vh;
            margin: 0;
            background-color: var(--dark-color);
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
            padding-bottom: 50px; 
        }

        /* --- UI Bar (Top Left Fixed) --- */
        #ui-bar {
            position: fixed;
            top: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            padding: 15px;
            background-color: #272744;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            z-index: 200;
            gap: 10px;
        }

        .resource-display {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.4em;
        }
        
        #gold-amount { color: var(--gold-color); font-weight: bold; }
        #power-amount { color: var(--power-color); font-weight: bold; }
        
        /* --- Monster Stats UI (Top Right Fixed) --- */
        #monster-stats-bar {
            position: fixed;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            padding: 15px;
            background-color: #442727;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            z-index: 200;
            gap: 10px;
        }

        .stat-display {
            font-size: 1.1em;
            color: #ccc;
        }
        .stat-value {
            font-weight: bold;
            color: var(--accent-color);
        }

        /* --- Game Container & Grid --- */
        #game-container {
            position: relative;
            width: var(--grid-width);
            height: var(--grid-height);
            margin: 20px auto; 
            border: 5px solid #333;
            background-color: #0a0a0a;
            box-sizing: content-box;
            z-index: 10;
        }
        
        /* --- Door Styles & HP Bar --- */
        #door {
            position: absolute;
            /* Door remains vertically centered on the top edge */
            top: calc(0px - 30px); 
            left: 50%;
            transform: translateX(-50%);
            width: var(--cell-size);
            height: 30px;
            background-color: var(--door-color);
            border: 3px solid black;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: background-color 0.05s linear, opacity 1s ease-out; 
        }

        /* FIX: Door Knob above the door */
        #door-knob {
            position: absolute;
            right: 10px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--door-knob-color);
            z-index: 101; /* Ensure knob is visible */
        }

        #door-hp-visual {
            position: absolute;
            bottom: -5px; 
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 5px;
            background-color: gray;
            border-radius: 3px;
            overflow: hidden;
            z-index: 102; /* Above door and monster */
        }

        /* --- Monster Styles & HP Bar --- */
        #monster {
            position: absolute;
            /* FIX: Monster stays further away (approx 1.5 cell sizes above the door) */
            top: calc(0px - 60px - 30px); 
            left: 50%;
            transform: translateX(-50%);
            font-size: 4em; /* Larger size */
            transition: opacity 0.5s, transform 0.1s, top 1s ease-in-out, left 1s ease-in-out;
            z-index: 99;
            opacity: 1;
        }
        
        /* New: Monster Health Bar Container (attached to monster) */
        #monster-hp-visual {
            position: absolute;
            width: 40px; 
            height: 6px;
            background-color: gray;
            border-radius: 2px;
            overflow: hidden;
            /* Positioned just above the monster emoji */
            top: -10px; 
            left: 50%;
            transform: translateX(-50%);
            z-index: 100; 
        }
        #monster-hp-fill {
            height: 100%;
            width: 100%;
            background-color: var(--accent-color); /* Red */
            transition: width 0.3s ease;
        }

        /* --- Animations & Visuals --- */
        .upgrade-available {
            box-shadow: inset 0 0 0 4px rgba(0, 255, 0, 0.3); 
        }

        /* FIX: Increased vertical slam movement for door attack */
        @keyframes slam {
            0% { transform: translate(-50%, 0px); }
            50% { transform: translate(-50%, 15px); } /* Increased Y movement */
            100% { transform: translate(-50%, 0px); }
        }

        .monster-slam {
            animation: slam 0.2s ease-out;
        }
        
        .monster-hit {
            opacity: 0.5 !important;
            transition: opacity 0.05s ease-out !important;
        }
        
        /* FIX: Smooth pulse for build mode plus signs */
        @keyframes pulse {
            0% { opacity: 0.5; transform: scale(0.8); }
            50% { opacity: 1; transform: scale(1.1); } /* Peak */
            100% { opacity: 0.5; transform: scale(0.8); } /* Returns smoothly to start */
        }
        /* FIX: Smooth pulse for build mode plus signs */
        .build-plus {
            position: absolute; 
            font-size: 2em; 
            color: rgba(192, 192, 192, 0.6); 
            /* Seamlessly loop the pulse animation (removed 'alternate') */
            animation: pulse 1s infinite ease-in-out; 
            pointer-events: none; 
        }
        
        /* --- Grid & Structures --- */
        #game-grid {
            display: grid;
            grid-template-columns: repeat(var(--grid-cols), var(--cell-size));
            grid-template-rows: repeat(var(--grid-rows), var(--cell-size));
            width: 100%;
            height: 100%;
            background-color: #000;
        }
        .grid-tile {
            width: var(--cell-size);
            height: var(--cell-size);
            border: 1px solid #444; 
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            user-select: none;
            cursor: pointer;
            transition: box-shadow 0.2s ease;
        }
        .structure-icon {
            font-size: 2.5em; 
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        /* Turret (Bow) rotation setup */
        .turret-bow {
            display: inline-block;
            transform-origin: 50% 50%;
            transition: transform 0.2s linear; /* Smooth rotation */
        }
        
        /* Projectile */
        .projectile {
            position: absolute;
            font-size: 1.5em;
            color: yellow;
            transition: all 0.5s linear; 
            z-index: 110;
            transform-origin: center center; /* Ensure rotation is centered */
        }

        /* --- Floating Resources --- */
        .floating-resource {
            position: absolute;
            font-size: 1.2em; 
            font-weight: bold;
            pointer-events: none;
            z-index: 150;
            animation: drift-and-fade 1s ease-out forwards;
        }
        
        @keyframes drift-and-fade {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(0, -30px) scale(0.6); opacity: 0; }
        }
        
        .floating-gold { color: var(--gold-color); }
        .floating-power { color: var(--power-color); }

        /* --- Menu and Tooltip styles retained --- */
        .info-tooltip {
            position: absolute; top: -30px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8); color: white; padding: 5px 10px; border-radius: 5px;
            font-size: 0.8em; white-space: nowrap; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s; pointer-events: none; z-index: 300;
        }
        #door:hover .info-tooltip,
        .grid-tile:hover .info-tooltip { opacity: 1; visibility: visible; }
        #menu-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); display: none; align-items: center; justify-content: center; z-index: 250; }
        #action-menu, #build-menu { background-color: #272744; padding: 20px; border-radius: 10px; box-shadow: 0 0 20px rgba(0, 0, 0, 0.5); text-align: center; }
        .menu-title { font-size: 1.5em; margin-bottom: 15px; color: var(--accent-color); }
        .menu-button { padding: 10px 20px; margin: 5px; cursor: pointer; border: none; border-radius: 5px; font-weight: bold; transition: background-color 0.2s; }
        #upgrade-btn { background-color: #4CAF50; color: white; }
        #sell-btn { background-color: #f44336; color: white; }
        #close-btn { background-color: #555; color: white; margin-top: 15px; }
        .disabled-btn { background-color: #888 !important; cursor: not-allowed !important; }

        .hint {
            position: fixed;
            bottom: 10px;
            color: rgba(255, 255, 255, 0.7);
            z-index: 50;
        }
    </style>
</head>
<body>

    <div id="ui-bar">
        <div class="resource-display">üí∞ Gold: <span id="gold-amount">100</span></div>
        <div class="resource-display">‚ö° Power: <span id="power-amount">0</span></div>
        <div class="resource-display">Wave: <span id="wave-count">1</span></div>
    </div>
    
    <div id="monster-stats-bar">
        <div class="stat-display">
            Monster Stats
        </div>
        <div class="stat-display">
            Damage: <span id="monster-damage" class="stat-value">0</span>
        </div>
        <div class="stat-display">
            Wave: <span id="monster-wave" class="stat-value">1</span>
        </div>
        <div class="stat-display">
            Amount: <span class="stat-value">1</span> (Current)
        </div>
    </div>

    <div id="game-container">
        <div id="door-hp-visual"><div id="door-hp-fill-overlay"></div></div>

        <div id="door" class="tooltip-container">
            <div id="door-knob"></div>
            <span class="info-tooltip" id="door-tooltip"></span>
        </div>
        
        <div id="monster">
            <div id="monster-hp-visual"><div id="monster-hp-fill"></div></div>
            üíÄ
        </div>
        
        <div id="game-grid">
            </div>
    </div>

    <p class="hint">
        Press **E** to toggle **Build Mode** | Click on occupied cells to **Upgrade/Sell**
    </p>

    <div id="menu-overlay">
        <div id="action-menu">
            <div class="menu-title" id="menu-title"></div>
            <p id="menu-info"></p>
            <button class="menu-button" id="upgrade-btn"></button>
            <button class="menu-button" id="sell-btn"></button>
            <button class="menu-button" id="close-btn">Close</button>
        </div>
        
        <div id="build-menu" style="display: none;">
            <div class="menu-title">Place Structure</div>
            <button class="menu-button" onclick="placeStructure('turret')" data-cost="150">üèπ Turret (150üí∞)</button>
            <button class="menu-button" onclick="placeStructure('generator')" data-cost="100">‚òÄÔ∏è Generator (100üí∞)</button>
            <button class="menu-button" onclick="closeMenu()">Cancel</button>
        </div>
    </div>

    <script>
        // --- CONSTANTS ---
        const GRID_COLS = 15;
        const GRID_ROWS = 4;
        const CELL_SIZE = 60;
        const TILE_COUNT = GRID_COLS * GRID_ROWS;
        // The bed should be near the center of the third row
        const BED_TILE_INDEX = (GRID_ROWS - 2) * GRID_COLS + Math.floor(GRID_COLS / 2); 
        
        // --- LEVEL TABLES (Retained) ---
        const DOOR_LEVELS = [
            { cost: 0, health: 300, baseAttack: 10 }, { cost: 100, health: 500, baseAttack: 10 },
            { cost: 250, health: 800, baseAttack: 10 }, { cost: 500, health: 1200, baseAttack: 10 },
            { cost: 1000, health: 2000, baseAttack: 10 },
        ];
        const BED_LEVELS = [
            { cost: 0, goldGen: 100, powerGen: 0 }, { cost: 150, goldGen: 2, powerGen: 0 },
            { cost: 400, goldGen: 400, powerGen: 0 }, { cost: 900, goldGen: 8, powerGen: 0 },
            { cost: 1800, goldGen: 1500, powerGen: 0 }
        ];
        const GENERATOR_LEVELS = [
            { cost: 100, goldGen: 0, powerGen: 1 }, { cost: 200, goldGen: 0, powerGen: 3 },
            { cost: 450, goldGen: 0, powerGen: 6 }, { cost: 900, goldGen: 0, powerGen: 12 },
            { cost: 1800, goldGen: 0, powerGen: 25 }
        ];
        const TURRET_LEVELS = [
            { cost: 150, damage: 20, fireRate: 1500 }, { cost: 300, damage: 35, fireRate: 1200 },
            { cost: 600, damage: 60, fireRate: 900 }, { cost: 1200, damage: 100, fireRate: 700 },
            { cost: 2500, damage: 180, fireRate: 500 }
        ];
        const STRUCTURES = {
            door: { levels: DOOR_LEVELS, icon: 'üö™' },
            bed: { levels: BED_LEVELS, icon: 'üõèÔ∏è' },
            generator: { levels: GENERATOR_LEVELS, icon: '‚òÄÔ∏è' },
            turret: { levels: TURRET_LEVELS, icon: 'üèπ' }
        };


        // --- GAME STATE ---
        let gold = 100;
        let power = 0;
        let isBuildMode = false; 
        let isGameOver = false; 
        let door = {
            type: 'door', level: 1, 
            hp: DOOR_LEVELS[0].health, maxHp: DOOR_LEVELS[0].health, 
            upgradeCost: DOOR_LEVELS[1].cost,
        };
        let monster = {
            hp: 500, maxHp: 500, attack: DOOR_LEVELS[0].baseAttack, wave: 1, retreating: false, isAttacking: true
        };
        let currentTileTarget = null; 

        // Initialize Tile Grid 
        let tiles = Array(TILE_COUNT).fill(null).map((_, index) => {
            if (index === BED_TILE_INDEX) {
                const bedStats = BED_LEVELS[0];
                return {
                    type: 'bed', level: 1, 
                    goldEffect: bedStats.goldGen, powerEffect: bedStats.powerGen,
                    cost: bedStats.cost, element: null
                };
            }
            return null;
        });

        // --- DOM ELEMENTS ---
        const uiGold = document.getElementById('gold-amount');
        const uiPower = document.getElementById('power-amount');
        const uiWave = document.getElementById('wave-count');
        const monsterDamageDisplay = document.getElementById('monster-damage');
        const monsterWaveDisplay = document.getElementById('monster-wave');
        const doorElement = document.getElementById('door');
        const monsterElement = document.getElementById('monster');
        const monsterHpFill = document.getElementById('monster-hp-fill');
        const gridElement = document.getElementById('game-grid');
        const doorTooltip = document.getElementById('door-tooltip');
        const doorHpFillOverlay = document.getElementById('door-hp-fill-overlay');
        const upgradeBtn = document.getElementById('upgrade-btn');
        const sellBtn = document.getElementById('sell-btn');
        const closeBtn = document.getElementById('close-btn');

        let monsterAttackInterval = null;


        // --- RESOURCE GENERATION & FLOATING TEXT ---
        function generateResources() {
            if (isGameOver) return;
            let goldIncome = 0;
            let powerIncome = 0;

            tiles.forEach(tile => {
                if (tile && (tile.type === 'bed' || tile.type === 'generator')) {
                    const goldAmount = tile.goldEffect || 0;
                    const powerAmount = tile.powerEffect || 0;
                    
                    goldIncome += goldAmount;
                    powerIncome += powerAmount;

                    if (goldAmount > 0 || powerAmount > 0) {
                        displayFloatingResource(tile.element, goldAmount, powerAmount);
                    }
                }
            });

            gold += goldIncome;
            power += powerIncome;
            updateUI();
        }
        
        // FIX: Adjusted displayFloatingResource for random positioning centered in cell
        function displayFloatingResource(sourceElement, goldAmount, powerAmount) {
            if (!sourceElement) return;

            const rect = sourceElement.getBoundingClientRect();
            const containerRect = document.getElementById('game-container').getBoundingClientRect();
            
            // Random position centered over the cell: X variance from -20px to +20px from center
            const randomOffsetX = 0;
            const startX = rect.left + rect.width / 2 - containerRect.left + randomOffsetX;
            const startY = rect.top - containerRect.top; 

            if (goldAmount > 0) {
                const goldEl = createFloatingElement(`+${goldAmount}üí∞`, 'floating-gold', startX, startY);
                document.getElementById('game-container').appendChild(goldEl);
                setTimeout(() => goldEl.remove(), 1000); 
            }
            
            if (powerAmount > 0) {
                const powerEl = createFloatingElement(`+${powerAmount}‚ö°`, 'floating-power', startX, startY - 10);
                document.getElementById('game-container').appendChild(powerEl);
                setTimeout(() => powerEl.remove(), 1000);
            }
        }
        
        function createFloatingElement(text, className, x, y) {
            const el = document.createElement('div');
            el.className = `floating-resource ${className}`;
            el.textContent = text;
            el.style.left = `${x - 15}px`; // FIX: Subtract 15px to account for half its width, centering it visually.
            el.style.top = `${y}px`;
            return el;
        }

        setInterval(generateResources, 1000);

        // --- MONSTER & DOOR LOGIC --- 

        function startMonsterAttack() {
            monster.isAttacking = true;
            if (monsterAttackInterval) clearInterval(monsterAttackInterval);
            
            // Set initial position for attack transition
            monsterElement.style.top = `calc(0px - 60px - 30px)`; 
            
            monsterAttackInterval = setInterval(() => {
                if (monster.isAttacking && !monster.retreating && !isGameOver) {
                    
                    // Trigger slam animation for visual effect
                    monsterElement.classList.add('monster-slam');
                    setTimeout(() => {
                        monsterElement.classList.remove('monster-slam');
                    }, 200);

                    door.hp -= monster.attack;
                    if (door.hp < 0) { 
                        door.hp = 0;
                        endGameSequence(); 
                        return;
                    }
                    
                    doorFlashHit(); 
                    
                    if (monster.hp / monster.maxHp < 0.1 && !monster.retreating) {
                        clearInterval(monsterAttackInterval);
                        retreatMonster();
                    }
                    updateUI();
                } else if (!monster.isAttacking || isGameOver) {
                    clearInterval(monsterAttackInterval);
                }
            }, 1500);
        }
        
        function endGameSequence() {
            isGameOver = true;
            monster.isAttacking = false;
            clearInterval(monsterAttackInterval);
            turretIntervals.forEach(clearInterval); 
            doorElement.style.opacity = 0; 
            
            const bedCol = BED_TILE_INDEX % GRID_COLS;
            const bedRow = Math.floor(BED_TILE_INDEX / GRID_COLS);
            
            const targetX = bedCol * CELL_SIZE + CELL_SIZE / 2;
            const targetY = bedRow * CELL_SIZE + CELL_SIZE / 2;
            
            monsterElement.style.top = `${targetY}px`;
            monsterElement.style.left = `${targetX}px`;
            // Center monster emoji (4em wide/tall, approx 60px)
            monsterElement.style.transform = `translate(-50%, -50%)`; 
            
            setTimeout(() => {
                alert(`GAME OVER on Wave ${monster.wave}! The monster reached your bed!`);
            }, 1000); 
        }


        function doorFlashHit() {
            doorElement.classList.add('door-hit');
            setTimeout(() => {
                doorElement.classList.remove('door-hit');
            }, 50);
        }
        
        function retreatMonster() {
            monster.retreating = true;
            monster.isAttacking = false;
            monsterElement.style.opacity = 0;
            
            setTimeout(() => {
                monster.wave++;
                monster.maxHp = Math.round(monster.maxHp * 1.5);
                monster.attack = Math.round(monster.attack * 1.5);
                startWave(); 
            }, Math.random() * 10000 + 10000); 
        }

        function damageMonster(damage) {
            if (monster.retreating || isGameOver) return;
            monster.hp -= damage;
            
            monsterElement.classList.add('monster-hit');
            setTimeout(() => {
                monsterElement.classList.remove('monster-hit');
            }, 50);
            
            if (monster.hp <= 0) {
                monster.hp = 0;
                monster.isAttacking = false;
                monsterElement.style.opacity = 0;
                gold += Math.round(monster.maxHp * 0.5); 
                retreatMonster(); 
            }
            updateUI(); // Update HP bar immediately
        }

        // --- TURRET LOGIC ---
        let turretIntervals = [];
        
        function updateTurretIntervals() {
            turretIntervals.forEach(clearInterval);
            turretIntervals = [];

            tiles.forEach((tile, index) => {
                if (tile && tile.type === 'turret') {
                    const turretStats = STRUCTURES.turret.levels[tile.level - 1];
                    
                    // Set up aiming interval only for visual updates (no firing here)
                    const aimInterval = setInterval(() => {
                        if (tile.element && monster.isAttacking && !monster.retreating && !isGameOver) {
                            aimTurret(tile.element);
                        }
                    }, 100); 
                    
                    const fireInterval = setInterval(() => {
                        if (monster.isAttacking && !monster.retreating && !isGameOver) {
                            fireProjectile(index);
                        }
                    }, turretStats.fireRate);
                    
                    turretIntervals.push(aimInterval);
                    turretIntervals.push(fireInterval);
                }
            });
        }
        
        // FIX: Aim Turret (Bow) function
        function aimTurret(turretElement) {
            const turretRect = turretElement.getBoundingClientRect();
            const containerRect = document.getElementById('game-container').getBoundingClientRect();
            
            const turretX = turretRect.left + turretRect.width / 2 - containerRect.left;
            const turretY = turretRect.top + turretRect.height / 2 - containerRect.top;
            
            const monsterX = parseFloat(monsterElement.style.left) || containerRect.width / 2;
            const monsterY = parseFloat(monsterElement.style.top) || -65;
            
            const deltaX = monsterX - turretX;
            const deltaY = monsterY - turretY;
            
            // Calculate angle, rotating the bow tip towards the monster
            const angleRad = Math.atan2(deltaY, deltaX);
            const angleDeg = angleRad * (180 / Math.PI);
            
            // Adjust angle so the bow tip points *out* (typically 0 degrees is right, so we add 90)
            const bowRotation = angleDeg; 
            
            const bowElement = turretElement.querySelector('.turret-bow');
            if (bowElement) {
                bowElement.style.transform = `rotate(${bowRotation}deg)`;
            }
        }


        // FIX: Projectile is now a diamond emoji and angled
        function fireProjectile(tileIndex) {
            const tile = tiles[tileIndex];
            if (!tile.element) return;
            
            const turretStats = STRUCTURES.turret.levels[tile.level - 1];

            const proj = document.createElement('div');
            proj.className = 'projectile';
            proj.textContent = '‚ô¶Ô∏è'; // FIX: Changed to Diamond emoji
            
            const tileRect = tile.element.getBoundingClientRect();
            const containerRect = document.getElementById('game-container').getBoundingClientRect();

            const startX = tileRect.left + tileRect.width / 2 - containerRect.left;
            const startY = tileRect.top + tileRect.height / 2 - containerRect.top;
            
            proj.style.left = `${startX}px`;
            proj.style.top = `${startY}px`;
            
            document.getElementById('game-container').appendChild(proj);
            
            const monsterX = parseFloat(monsterElement.style.left) || containerRect.width / 2;
            const monsterY = parseFloat(monsterElement.style.top) || -65;
            
            const deltaX = monsterX - startX;
            const deltaY = monsterY - startY;
            const angleRad = Math.atan2(deltaY, deltaX);
            const angleDeg = angleRad * (180 / Math.PI);
            
            // Rotate the diamond to point at the monster (0 deg is right)
            const diamondRotation = angleDeg; 

            setTimeout(() => {
                proj.style.transform = `rotate(${diamondRotation}deg)`;
                proj.style.left = `${monsterX}px`;
                proj.style.top = `${monsterY}px`;
            }, 10);
            
            const damage = turretStats.damage;
            
            setTimeout(() => {
                damageMonster(damage);
                proj.remove(); 
            }, 500); 
        }

        // --- UI / BUILD MODE LOGIC ---

        function updateUI() {
            // FIX: Add toLocaleString for comma separated numbers
            uiGold.textContent = gold.toLocaleString();
            uiPower.textContent = power.toLocaleString();
            uiWave.textContent = monster.wave;
            
            // Monster Stats Display Update
            monsterDamageDisplay.textContent = monster.attack;
            monsterWaveDisplay.textContent = monster.wave;

            // Door HP
            const doorPercent = (door.hp / door.maxHp) * 100;
            doorHpFillOverlay.style.width = `${doorPercent}%`;
            doorTooltip.textContent = `Door Lvl ${door.level} (${door.hp.toLocaleString()}/${door.maxHp.toLocaleString()} HP)`;
            
            // Monster HP
            const monsterPercent = (monster.hp / monster.maxHp) * 100;
            monsterHpFill.style.width = `${monsterPercent}%`;

            renderGrid();
        }

        function toggleBuildMode() {
            isBuildMode = !isBuildMode;
            renderGrid(); 
            if (isBuildMode) closeMenu(); 
        }

        document.addEventListener('keydown', (e) => {
            if ((e.key === 'e' || e.key === 'E') && !isGameOver) {
                e.preventDefault();
                toggleBuildMode();
            }
        });

        function handleTileClick(index) {
            if (isGameOver) return;
            closeMenu();
            
            const tile = tiles[index];

            if (tile) {
                showActionMenu(tile, tile.type, index);
            } else if (isBuildMode) {
                showBuildMenu(index);
            } 
        }
        
        function handleDoorClick() {
            if (isGameOver) return;
            closeMenu();
            showActionMenu(door, 'door', 'door');
        }

        // --- UPGRADE/SELL LOGIC (Retained) ---
        function showBuildMenu(tileIndex) {
            currentTileTarget = tileIndex;
            document.getElementById('build-menu').querySelector('button[data-cost="100"]').classList.toggle('disabled-btn', gold < 100);
            document.getElementById('build-menu').querySelector('button[data-cost="150"]').classList.toggle('disabled-btn', gold < 150);

            document.getElementById('menu-overlay').style.display = 'flex';
            document.getElementById('build-menu').style.display = 'block';
            document.getElementById('action-menu').style.display = 'none';
        }

        function placeStructure(type) {
            const blueprint = STRUCTURES[type];
            const cost = blueprint.levels[0].cost; 

            if (gold >= cost) {
                gold -= cost;
                
                let stats = blueprint.levels[0];
                let newTile = {
                    type: type, level: 1, cost: cost, 
                    goldEffect: stats.goldGen || 0, powerEffect: stats.powerGen || 0,
                    damage: stats.damage || 0, fireRate: stats.fireRate || 0,
                    element: null 
                };
                
                tiles[currentTileTarget] = newTile;
                
                closeMenu();
                renderGrid();
                updateTurretIntervals(); 
                updateUI();
                toggleBuildMode(); 
            } else {
                alert("Not enough gold!");
            }
        }
        
        function showActionMenu(target, type, tileIndex = null) {
            currentTileTarget = target;
            currentTileTarget.tileIndex = tileIndex; 
            
            const blueprint = STRUCTURES[type];
            const maxLevel = blueprint.levels.length;
            
            document.getElementById('menu-title').textContent = `${blueprint.icon} ${type.charAt(0).toUpperCase() + type.slice(1)} - Level ${target.level}`;
            
            const isMaxLevel = target.level >= maxLevel;
            const nextLevelIndex = target.level; 

            let nextCost = 0;
            if (!isMaxLevel) {
                 nextCost = blueprint.levels[nextLevelIndex].cost;
            }
            
            let infoText = "";
            const currentStats = blueprint.levels[target.level - 1];

            if (type === 'door') {
                const nextStats = isMaxLevel ? null : DOOR_LEVELS[nextLevelIndex];
                infoText = `Current HP: ${target.maxHp.toLocaleString()}. Next HP: ${nextStats ? nextStats.health.toLocaleString() : 'MAX'}`;
            } else if (type === 'turret') {
                const nextStats = isMaxLevel ? null : TURRET_LEVELS[nextLevelIndex];
                infoText = `Current Dmg: ${currentStats.damage}, Rate: ${(1000/currentStats.fireRate).toFixed(1)}/s. Next Dmg: ${nextStats ? nextStats.damage : 'MAX'}`;
            } else { 
                const nextStats = isMaxLevel ? null : blueprint.levels[nextLevelIndex];
                infoText = `Current Gen: ${currentStats.goldGen}üí∞/${currentStats.powerGen}‚ö°. Next Gen: ${nextStats ? nextStats.goldGen : 'MAX'}üí∞/${nextStats ? nextStats.powerGen : 'MAX'}‚ö°`;
            }
            document.getElementById('menu-info').textContent = infoText;

            if (isMaxLevel) {
                 upgradeBtn.textContent = "MAX LEVEL";
                 upgradeBtn.classList.add('disabled-btn');
            } else {
                upgradeBtn.textContent = `Upgrade (${nextCost.toLocaleString()}üí∞)`;
                upgradeBtn.classList.remove('disabled-btn');
                upgradeBtn.classList.toggle('disabled-btn', gold < nextCost);
            }
            
            const isBed = type === 'bed';
            const isDoor = type === 'door';
            sellBtn.textContent = isDoor || isBed ? 'Cannot Sell' : `Sell (${Math.floor(blueprint.levels[target.level - 1].cost / 2).toLocaleString()}üí∞)`;
            sellBtn.classList.toggle('disabled-btn', isDoor || isBed);
            
            document.getElementById('menu-overlay').style.display = 'flex';
            document.getElementById('action-menu').style.display = 'block';
            document.getElementById('build-menu').style.display = 'none';
        }

        function upgradeStructure() {
            const target = currentTileTarget;
            const type = target.type; 
            const isDoor = type === 'door';
            const blueprint = STRUCTURES[type];
            const maxLevel = blueprint.levels.length;
            const nextLevelIndex = target.level; 

            if (target.level >= maxLevel) return;

            const nextStats = blueprint.levels[nextLevelIndex];
            const cost = nextStats.cost;

            if (gold >= cost) {
                gold -= cost;
                target.level++;

                if (isDoor) {
                    door.maxHp = nextStats.health;
                    door.hp = door.maxHp; 
                    door.upgradeCost = nextLevelIndex + 1 < maxLevel ? blueprint.levels[nextLevelIndex + 1].cost : 0;
                    monster.attack = nextStats.baseAttack; 
                } else {
                    target.cost = nextStats.cost; 
                    target.goldEffect = nextStats.goldGen || 0;
                    target.powerEffect = nextStats.powerGen || 0;
                    target.damage = nextStats.damage || 0;
                    target.fireRate = nextStats.fireRate || 0;
                    
                    if (type === 'turret') {
                        updateTurretIntervals();
                    }
                }
                
                closeMenu();
                renderGrid(); 
                updateUI();
            } else {
                alert("Not enough gold!");
            }
        }

        function sellStructure() {
            const target = currentTileTarget;
            if (target.type === 'bed' || target.type === 'door') return;
            
            const cost = STRUCTURES[target.type].levels[target.level - 1].cost;
            const sellValue = Math.floor(cost / 2);
            gold += sellValue;
            
            tiles[target.tileIndex] = null;
            
            closeMenu();
            renderGrid();
            updateTurretIntervals();
            updateUI();
        }

        function closeMenu() {
            document.getElementById('menu-overlay').style.display = 'none';
            currentTileTarget = null;
        }
        
        function isUpgradableAndAffordable(type, currentLevel) {
            const blueprint = STRUCTURES[type];
            const maxLevel = blueprint.levels.length;

            if (currentLevel >= maxLevel) return false;

            const nextLevelIndex = currentLevel;
            const cost = blueprint.levels[nextLevelIndex].cost;

            return gold >= cost;
        }

        // --- INITIALIZATION ---

        function renderGrid() {
            gridElement.innerHTML = '';
            
            // Door upgrade cue check
            if (isUpgradableAndAffordable('door', door.level)) {
                doorElement.classList.add('upgrade-available');
            } else {
                doorElement.classList.remove('upgrade-available');
            }


            for(let index = 0; index < TILE_COUNT; index++) {
                const tileElement = document.createElement('div');
                tileElement.className = 'grid-tile tooltip-container';
                tileElement.setAttribute('data-index', index);
                tileElement.onclick = () => handleTileClick(index);
                
                const tile = tiles[index];
                
                if (tile) {
                    const blueprint = STRUCTURES[tile.type];
                    
                    if (isUpgradableAndAffordable(tile.type, tile.level)) {
                        tileElement.classList.add('upgrade-available');
                    } else {
                         tileElement.classList.remove('upgrade-available');
                    }

                    // Render structure content
                    let iconHTML = blueprint.icon;
                    if (tile.type === 'turret') {
                        // Wrap turret icon in a span for rotation/aiming
                        iconHTML = `<span class="turret-bow">${blueprint.icon}</span>`;
                    }
                    
                    tileElement.innerHTML = `
                        <span class="structure-icon">${iconHTML}</span>
                        <span class="info-tooltip">${blueprint.icon} Lvl ${tile.level}</span>
                    `;
                    tile.element = tileElement; 
                    
                    // If turret, ensure it aims immediately on re-render
                    if (tile.type === 'turret' && monster.isAttacking) {
                        aimTurret(tileElement);
                    }
                }
                
                if (isBuildMode) {
                    tileElement.classList.add('grid-visual-on');
                    if (!tile) {
                        const plus = document.createElement('div');
                        plus.className = 'build-plus';
                        plus.textContent = '+';
                        tileElement.appendChild(plus);
                    }
                }
                
                gridElement.appendChild(tileElement);
            }
        }
        
        // Connect event handlers
        document.getElementById('door').onclick = handleDoorClick;
        document.getElementById('door-hp-visual').onclick = handleDoorClick; 
        upgradeBtn.onclick = upgradeStructure;
        sellBtn.onclick = sellStructure;
        closeBtn.onclick = closeMenu; 

        function startWave() {
            if (isGameOver) return;
            monster.isAttacking = true;
            monster.retreating = false;
            monster.hp = monster.maxHp;
            monsterElement.style.opacity = 1;
            // Reset monster position further away from door
            monsterElement.style.top = `calc(0px - 60px - 30px)`; 
            monsterElement.style.left = '50%';
            monsterElement.style.transform = 'translateX(-50%)'; 
            startMonsterAttack();
        }

        // Final Setup
        renderGrid();
        updateUI();
        startWave();
        updateTurretIntervals();
    </script>
</body>
</html>